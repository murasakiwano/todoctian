// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: queries.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createProject = `-- name: CreateProject :exec
INSERT INTO projects (
  id, name, created_at
) VALUES (
  $1, $2, $3
)
`

type CreateProjectParams struct {
	ID        pgtype.UUID
	Name      string
	CreatedAt pgtype.Timestamp
}

func (q *Queries) CreateProject(ctx context.Context, arg CreateProjectParams) error {
	_, err := q.db.Exec(ctx, createProject, arg.ID, arg.Name, arg.CreatedAt)
	return err
}

const createTask = `-- name: CreateTask :exec
INSERT INTO tasks (
  id, project_id, name, status, "order", parent_task_id, created_at
) VALUES (
  $1, $2, $3, $4, $5, $6, $7
)
`

type CreateTaskParams struct {
	ID           pgtype.UUID
	ProjectID    pgtype.UUID
	Name         string
	Status       string
	Order        int32
	ParentTaskID pgtype.UUID
	CreatedAt    pgtype.Timestamp
}

func (q *Queries) CreateTask(ctx context.Context, arg CreateTaskParams) error {
	_, err := q.db.Exec(ctx, createTask,
		arg.ID,
		arg.ProjectID,
		arg.Name,
		arg.Status,
		arg.Order,
		arg.ParentTaskID,
		arg.CreatedAt,
	)
	return err
}

const deleteProject = `-- name: DeleteProject :one
DELETE FROM projects
WHERE id = $1
RETURNING id, created_at, name
`

func (q *Queries) DeleteProject(ctx context.Context, id pgtype.UUID) (Project, error) {
	row := q.db.QueryRow(ctx, deleteProject, id)
	var i Project
	err := row.Scan(&i.ID, &i.CreatedAt, &i.Name)
	return i, err
}

const deleteTask = `-- name: DeleteTask :exec
DELETE FROM tasks
WHERE id = $1
`

func (q *Queries) DeleteTask(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteTask, id)
	return err
}

const getProject = `-- name: GetProject :one
SELECT id, created_at, name FROM projects
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetProject(ctx context.Context, id pgtype.UUID) (Project, error) {
	row := q.db.QueryRow(ctx, getProject, id)
	var i Project
	err := row.Scan(&i.ID, &i.CreatedAt, &i.Name)
	return i, err
}

const getProjectByName = `-- name: GetProjectByName :one
SELECT id, created_at, name FROM projects
WHERE name = $1 LIMIT 1
`

func (q *Queries) GetProjectByName(ctx context.Context, name string) (Project, error) {
	row := q.db.QueryRow(ctx, getProjectByName, name)
	var i Project
	err := row.Scan(&i.ID, &i.CreatedAt, &i.Name)
	return i, err
}

const getSubtasksDeep = `-- name: GetSubtasksDeep :many
WITH RECURSIVE subtasks AS (
  -- Base case: Direct children of the specified parent task
  SELECT id, created_at, parent_task_id, project_id, status, "order", name FROM tasks ts
  WHERE ts.parent_task_id = $1

  UNION

  -- Recursive step: For each found subtask, find its own children
  SELECT t.id, t.created_at, t.parent_task_id, t.project_id, t.status, t."order", t.name FROM tasks t
  INNER JOIN subtasks st ON t.parent_task_id = st.id
)
SELECT id, created_at, parent_task_id, project_id, status, "order", name FROM subtasks
`

type GetSubtasksDeepRow struct {
	ID           pgtype.UUID
	CreatedAt    pgtype.Timestamp
	ParentTaskID pgtype.UUID
	ProjectID    pgtype.UUID
	Status       string
	Order        int32
	Name         string
}

func (q *Queries) GetSubtasksDeep(ctx context.Context, parentTaskID pgtype.UUID) ([]GetSubtasksDeepRow, error) {
	rows, err := q.db.Query(ctx, getSubtasksDeep, parentTaskID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSubtasksDeepRow
	for rows.Next() {
		var i GetSubtasksDeepRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.ParentTaskID,
			&i.ProjectID,
			&i.Status,
			&i.Order,
			&i.Name,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSubtasksDirect = `-- name: GetSubtasksDirect :many
SELECT id, created_at, parent_task_id, project_id, status, "order", name FROM tasks
WHERE parent_task_id = $1
`

func (q *Queries) GetSubtasksDirect(ctx context.Context, parentTaskID pgtype.UUID) ([]Task, error) {
	rows, err := q.db.Query(ctx, getSubtasksDirect, parentTaskID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Task
	for rows.Next() {
		var i Task
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.ParentTaskID,
			&i.ProjectID,
			&i.Status,
			&i.Order,
			&i.Name,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTask = `-- name: GetTask :one
SELECT id, created_at, parent_task_id, project_id, status, "order", name FROM tasks
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetTask(ctx context.Context, id pgtype.UUID) (Task, error) {
	row := q.db.QueryRow(ctx, getTask, id)
	var i Task
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.ParentTaskID,
		&i.ProjectID,
		&i.Status,
		&i.Order,
		&i.Name,
	)
	return i, err
}

const getTasksByProject = `-- name: GetTasksByProject :many
SELECT id, created_at, parent_task_id, project_id, status, "order", name FROM tasks
WHERE project_id = $1
`

func (q *Queries) GetTasksByProject(ctx context.Context, projectID pgtype.UUID) ([]Task, error) {
	rows, err := q.db.Query(ctx, getTasksByProject, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Task
	for rows.Next() {
		var i Task
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.ParentTaskID,
			&i.ProjectID,
			&i.Status,
			&i.Order,
			&i.Name,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTasksByStatus = `-- name: GetTasksByStatus :many
SELECT id, created_at, parent_task_id, project_id, status, "order", name FROM tasks
WHERE project_id = $1 AND status = $2
`

type GetTasksByStatusParams struct {
	ProjectID pgtype.UUID
	Status    string
}

func (q *Queries) GetTasksByStatus(ctx context.Context, arg GetTasksByStatusParams) ([]Task, error) {
	rows, err := q.db.Query(ctx, getTasksByStatus, arg.ProjectID, arg.Status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Task
	for rows.Next() {
		var i Task
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.ParentTaskID,
			&i.ProjectID,
			&i.Status,
			&i.Order,
			&i.Name,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTasksInProjectRoot = `-- name: GetTasksInProjectRoot :many
SELECT id, created_at, parent_task_id, project_id, status, "order", name FROM tasks
WHERE project_id = $1 AND parent_task_id IS NULL
`

func (q *Queries) GetTasksInProjectRoot(ctx context.Context, projectID pgtype.UUID) ([]Task, error) {
	rows, err := q.db.Query(ctx, getTasksInProjectRoot, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Task
	for rows.Next() {
		var i Task
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.ParentTaskID,
			&i.ProjectID,
			&i.Status,
			&i.Order,
			&i.Name,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProjects = `-- name: ListProjects :many
SELECT id, created_at, name FROM projects
ORDER BY name
`

func (q *Queries) ListProjects(ctx context.Context) ([]Project, error) {
	rows, err := q.db.Query(ctx, listProjects)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Project
	for rows.Next() {
		var i Project
		if err := rows.Scan(&i.ID, &i.CreatedAt, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const offsetTaskOrders = `-- name: OffsetTaskOrders :exec

UPDATE tasks
SET "order" = "order" + 1000
WHERE project_id = $1::uuid
  AND (
    (parent_task_id IS NULL AND $2::uuid IS NULL) OR
    (parent_task_id = $2::uuid)
  )
`

type OffsetTaskOrdersParams struct {
	ProjectID    pgtype.UUID
	ParentTaskID pgtype.UUID
}

// WARN: the following two queries should be used together
// in the scope of a transaction!
func (q *Queries) OffsetTaskOrders(ctx context.Context, arg OffsetTaskOrdersParams) error {
	_, err := q.db.Exec(ctx, offsetTaskOrders, arg.ProjectID, arg.ParentTaskID)
	return err
}

const renameProject = `-- name: RenameProject :exec
UPDATE projects
SET name = $2
WHERE id = $1
`

type RenameProjectParams struct {
	ID   pgtype.UUID
	Name string
}

func (q *Queries) RenameProject(ctx context.Context, arg RenameProjectParams) error {
	_, err := q.db.Exec(ctx, renameProject, arg.ID, arg.Name)
	return err
}

const renameTask = `-- name: RenameTask :exec
UPDATE tasks
SET name = $2
WHERE id = $1
`

type RenameTaskParams struct {
	ID   pgtype.UUID
	Name string
}

func (q *Queries) RenameTask(ctx context.Context, arg RenameTaskParams) error {
	_, err := q.db.Exec(ctx, renameTask, arg.ID, arg.Name)
	return err
}

const updateTaskOrder = `-- name: UpdateTaskOrder :exec
UPDATE tasks
SET "order" = $2
WHERE id = $1
`

type UpdateTaskOrderParams struct {
	ID    pgtype.UUID
	Order int32
}

func (q *Queries) UpdateTaskOrder(ctx context.Context, arg UpdateTaskOrderParams) error {
	_, err := q.db.Exec(ctx, updateTaskOrder, arg.ID, arg.Order)
	return err
}

const updateTaskStatus = `-- name: UpdateTaskStatus :exec
UPDATE tasks
SET "status" = $2
WHERE id = $1
`

type UpdateTaskStatusParams struct {
	ID     pgtype.UUID
	Status string
}

func (q *Queries) UpdateTaskStatus(ctx context.Context, arg UpdateTaskStatusParams) error {
	_, err := q.db.Exec(ctx, updateTaskStatus, arg.ID, arg.Status)
	return err
}
